#include "head.h"

int main()
{
	char model,c;
	//游戏初始化
	system("clear");
	printf("choose model:\n");
	printf("input 1 : player vs player\n");printf("input 2 : player vs computer(black)\n");printf("input 3 : player vs computer(white)\n");
	scanf("%c",&model);

	initRecordBorard();
	recordtoDisplayArray();
	displayBoard();		
	printf("-----game start-----\n");
	printf("input q to quilt, and others to continue:");	
	c=getchar();
	if(c=='q'||c=='Q'||c==EOF)
		return 0;
	else
		;
	switch(model)
	{
		case '1': playersvs();break;
//		case '2': player_vs_computer_black();break;
//		case '3': player_vs_computer_white();break; 
	}
	

	return 0;
}

//初始化棋盘格局 
void initRecordBorard(void){
//通过双重循环，将aRecordBoard清0
	for(int i=0;i<SIZE;i++)
		for(int j=0;j<SIZE;j++)
			aRecordBoard[i][j]=0;
}

//将aRecordBoard中记录的棋子位置，转化到aDisplayBoardArray中
void recordtoDisplayArray(void){
//第一步：将aInitDisplayBoardArray中记录的空棋盘，复制到aDisplayBoardArray中
	for(int i=0;i<SIZE;i++)
		for(int j=0;j<SIZE*CHARSIZE+1+2;j++)
			aDisplayBoardArray[i][j]=aInitDisplayBoardArray[i][j];
//第二步：扫描aRecordBoard，当遇到非0的元素，将●或者◎复制到aDisplayBoardArray的相应位置上
	for(int i=1;i<SIZE+1;i++)
		for(int j=1;j<SIZE+1;j++)
			if(aRecordBoard[i][j]==1)
				{
				for(int k=0;k<2;k++)
						{						
					aDisplayBoardArray[15-i][j*2+k]=play1Pic[k];
							}
				}
			else if(aRecordBoard[i][j]==2)
				{
				for(int k=0;k<2;k++)
						{						
					aDisplayBoardArray[15-i][j*2+k]=play2Pic[k];
							}
				}
//注意：aDisplayBoardArray所记录的字符是中文字符，每个字符占2个字节。●和◎也是中文字符，每个也占2个字节。
}


void recordtoDisplayArray_current(int i,int j){
//第一步：扫描新输入到aRecordBoard的元素，当遇到非0的元素，将▲或者△复制到aDisplayBoardArray的相应位置上
			if(aRecordBoard[i][j]==1)
				{
				for(int k=0;k<2;k++)
						{						
					aDisplayBoardArray[15-i][j*2+k]=play1CurrentPic[k];
							}
				}
			else if(aRecordBoard[i][j]==2)
				{
				for(int k=0;k<2;k++)
						{						
					aDisplayBoardArray[15-i][j*2+k]=play2CurrentPic[k];
							}
				}
//注意：aDisplayBoardArray所记录的字符是中文字符，每个字符占2个字节。▲和△也是中文字符，每个也占2个字节。
}

//显示棋盘格局 
void displayBoard(void){
	int i;
	//第一步：清屏
	system("clear");   //清屏  
	//第二步：将aDisplayBoardArray输出到屏幕上
	for(int i=0;i<SIZE;i++)
		{
		for(int j=0;j<SIZE*CHARSIZE+1+2;j++)
			printf("%c",aDisplayBoardArray[i][j]);
		printf("\n");		
		}
	
	//第三步：输出最下面的一行字母A B .... 
	printf("  %c %c %c %c %c %c %c %c %c %c %c %c %c %c %c\n",'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O');
} 

int IsChessPiece(int i,int j)
{
	if(aRecordBoard[i][j]==1||aRecordBoard[i][j]==2)
		return 1;
	else
		return 0;
}

int OutChessboard(int i,int j)
{
	if((1<=i&&i<=15)&&(1<=j&&j<=15))
		return 0;
	else
		return 1;
}

//判断输赢
int winner_1(int m,int n){
	for(int i=0;i<4;i++)
	if(MyScoreBoard[m][n].info[i].linknum==4)
		return 1;
	return 0;
}

int winner_2(int m,int n){
	for(int i=0;i<4;i++)
	if(OppScoreBoard[m][n].info[i].linknum==4)
		return 1;
	return 0;
}

//玩家对战模式
void playersvs(void)
{	while(1)
	{
//判断程序继续运行还是退出
	int n,p;
	char a,b,c;
	c=getchar();
	if(c=='q'||c=='Q'||c==EOF)
		break;
	else
		;

//判断玩家1落子情况
	printf("---player1 input position:\n");
	scanf("%d",&n);
	scanf("%c",&a);
	for(;IsChessPiece(n,a-'A'+1)||OutChessboard(n,a-'A'+1);)
	{
	if(IsChessPiece(n,a-'A'+1))
		{
		printf("There was a chess piece, please choose other position\n");
		}
	else if(OutChessboard(n,a-'A'+1))
		{
		printf("This position is out of chessboard, please input again\n");
		}
	printf("---player1 input position:\n");
	scanf("%d",&n);
	scanf("%c",&a);	
	}
	
	Info(aRecordBoard);
	
/*	if(Ban_Hand(aRecordBoard,n,a-'A'+1)==1)				//判断禁手
	{
	printf("----break the rule: Long connect !!!----\n");
	break;
	}			
	else if(Ban_Hand(aRecordBoard,n,a-'A'+1)==2)
	{
		printf("----break the rule: Three-ban !!!----\n");
		break;
	}
	else if(Ban_Hand(aRecordBoard,n,a-'A'+1)==3)
	{
		printf("----break the rule: Four-ban !!!----\n");
		break;
	}
*/
	aRecordBoard[n][a-'A'+1]=1;
	
	recordtoDisplayArray_current(n,a-'A'+1);
   	displayBoard();

	for(int i=0;i<4;i++)
		printf("myinfo[%d]=%d ",i,MyScoreBoard[n][a-'A'+1].info[i].linknum);
	printf("\n");

	if(winner_1(n,a-'A'+1))		//判断玩家1是否赢得比赛
	{
		printf("----Player1 Win!!!----\n");
		break;
	}


//判断玩家2落子情况
	printf("---player2 input position:\n");
	scanf("%d",&p);
	scanf("%c",&b);
	for(;IsChessPiece(p,b-'A'+1)||OutChessboard(p,b-'A'+1);)
	{
	if(IsChessPiece(p,b-'A'+1))
	{
		printf("There was a chess piece, please choose other position\n");
	}
	else if(OutChessboard(p,b-'A'+1))
	{
		printf("This position is out of chessboard, please input again\n");
	}
	printf("---player2 input position:\n");
	scanf("%d",&p);
	scanf("%c",&b);	
	}	
	aRecordBoard[p][b-'A'+1]=2;
	recordtoDisplayArray_current(p,b-'A'+1);
   	displayBoard();

	for(int i=0;i<4;i++)
		printf("oppinfo[%d]=%d ",i,OppScoreBoard[p][b-'A'+1].info[i].linknum);
	printf("\n");

	if(winner_2(p,b-'A'+1))		//判断玩家2是否赢得比赛
	{
		printf("----Player2 Win!!!----\n");
		break;
	}

	recordtoDisplayArray();

	printf("input q to quit, and others to continue");
	c=getchar();
	}
}

void Info(int s[SIZE+1][SIZE+1])
{
//	s[x][y] = 1;			//填入棋子

	int temp[TSIZE][TSIZE];			//声明一个大棋盘，使其完全容纳住小棋盘
	for(int i=0;i<TSIZE;i++)
		for(int j=0;j<TSIZE;j++)
			temp[i][j]=8;		//初始化大棋盘边界，8对黑子,白子来说都相当与边界

	for(int i=1;i<=SIZE;i++)
		for(int j=1;j<=SIZE;j++)
			temp[i][j]=s[i][j];	//将小棋盘的值复制到大棋盘正中央，使其周围被厚厚的边界包裹
											
	for(int i=0;i<16;i++)			//清空数据
		for(int j=0;j<16;j++)
			for(int k=0;k<4;k++){
				MyScoreBoard[i][j].info[k].linknum=0;
				MyScoreBoard[i][j].info[k].oppnum=0;
				OppScoreBoard[i][j].info[k].linknum=0;
				OppScoreBoard[i][j].info[k].oppnum=0;
			}
//记录双方棋盘信息

	int m,n,i;

//记录白棋棋盘上每一点的信息

	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m][n+i]==2;i++)	OppScoreBoard[m][n].info[0].linknum++;		//记录――向连珠数
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m][n-i]==2;i++)	OppScoreBoard[m][n].info[0].linknum++;
										
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m+i][n+i]==2;i++)	OppScoreBoard[m][n].info[1].linknum++;		//记录 / 向连珠数
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m-i][n-i]==2;i++)	OppScoreBoard[m][n].info[1].linknum++;

	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m+i][n]==2;i++)	OppScoreBoard[m][n].info[2].linknum++;		//记录 | 向连珠数
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m-i][n]==2;i++)	OppScoreBoard[m][n].info[2].linknum++;

	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m+i][n-i]==2;i++)	OppScoreBoard[m][n].info[3].linknum++;		//记录 \ 向连珠数
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m-i][n+i]==2;i++)	OppScoreBoard[m][n].info[3].linknum++;

	
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m][n+i]==2;i++)	;	if(temp[m][n+i]==1)	OppScoreBoard[m][n].info[0].oppnum++;		//记录――向对手棋子数
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m][n-i]==2;i++)	;	if(temp[m][n-i]==1)	OppScoreBoard[m][n].info[0].oppnum++;

	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m+i][n+i]==2;i++)	;	if(temp[m+i][n+i]==1)	OppScoreBoard[m][n].info[1].oppnum++;		//记录/向对手棋子数
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m-i][n-i]==2;i++)	;	if(temp[m-i][n-i]==1)	OppScoreBoard[m][n].info[1].oppnum++;

	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m+i][n]==2;i++)	;	if(temp[m+i][n]==1)	OppScoreBoard[m][n].info[2].oppnum++;		//记录 | 向对手棋子数
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m-i][n]==2;i++)	;	if(temp[m-i][n]==1)	OppScoreBoard[m][n].info[2].oppnum++;

	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m+i][n-i]==2;i++)	;	if(temp[m-i][n-i]==1)	OppScoreBoard[m][n].info[3].oppnum++;		//记录\向对手棋子数
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m-i][n+i]==2;i++)	;	if(temp[m+i][n+i]==1)	OppScoreBoard[m][n].info[3].oppnum++;

//记录黑棋棋盘上每一点的信息

	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m][n+i]==1;i++)	MyScoreBoard[m][n].info[0].linknum++;		//记录――向连珠数
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m][n-i]==1;i++)	MyScoreBoard[m][n].info[0].linknum++;
										
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m+i][n+i]==1;i++)	MyScoreBoard[m][n].info[1].linknum++;		//记录 / 向连珠数
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m-i][n-i]==1;i++)	MyScoreBoard[m][n].info[1].linknum++;

	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m+i][n]==1;i++)	MyScoreBoard[m][n].info[2].linknum++;		//记录 | 向连珠数
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m-i][n]==1;i++)	MyScoreBoard[m][n].info[2].linknum++;

	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m+i][n-i]==1;i++)	MyScoreBoard[m][n].info[3].linknum++;		//记录 \ 向连珠数
	for(int m=1;m<16;m++)	for(int n=1;n<16;n++)	for(int i=1;temp[m-i][n+i]==1;i++)	MyScoreBoard[m][n].info[3].linknum++;

	
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m][n+i]==1;i++)	;	if(temp[m][n+i]==2)	MyScoreBoard[m][n].info[0].oppnum++;		//记录――向对手棋子数
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m][n-i]==1;i++)	;	if(temp[m][n-i]==2)	MyScoreBoard[m][n].info[0].oppnum++;

	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m+i][n+i]==1;i++)	;	if(temp[m+i][n+i]==2)	MyScoreBoard[m][n].info[1].oppnum++;		//记录/向对手棋子数
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m-i][n-i]==1;i++)	;	if(temp[m-i][n-i]==2)	MyScoreBoard[m][n].info[1].oppnum++;

	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m+i][n]==1;i++)	;	if(temp[m+i][n]==2)	MyScoreBoard[m][n].info[2].oppnum++;		//记录 | 向对手棋子数
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m-i][n]==1;i++)	;	if(temp[m-i][n]==2)	MyScoreBoard[m][n].info[2].oppnum++;

	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m+i][n-i]==1;i++)	;	if(temp[m-i][n-i]==2)	MyScoreBoard[m][n].info[3].oppnum++;		//记录\向对手棋子数
	for(m=1;m<16;m++)	for(n=1;n<16;n++)	for(i=1;temp[m-i][n+i]==1;i++)	;	if(temp[m+i][n+i]==2)	MyScoreBoard[m][n].info[3].oppnum++;

/*	for(int i=0;i<4;i++)					//判断长连禁手
	if(MyScoreBoard[m][n].info[i].linknum>4)
		return long_connect;
*/
//33禁手
//44禁手



				
}






